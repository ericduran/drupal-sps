<?php

/**
 * Implements hook_menu().
 */
function collection_menu() {
  $items = array();

  $items['collection/autocomplete/%'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'collection_autocomplete',
    'access arguments' => array('access content') // @TODO make better
  );

  return $items;
}

/**
 * Implements hook_entity_info().
 */
function collection_entity_info() {
  $return = array(
    'collection' => array(
      'label' => t('Collection'),
      'plural label' => t('Collections'),
      'description' => t('Collection Entity Type.'),
      'entity class' => "Drupal\\collection\\Collection",
      'controller class' => "Drupal\\collection\\CollectionController",
      'base table' => 'collection',
      'fieldable' => FALSE,
      'exportable' => TRUE,
      'entity keys' => array(
        'id' => 'cid',
        'name' => 'name',
        'status' => 'status',
        'module' => 'module',
        'label' => 'label',
      ),
      'label callback' => 'entity_class_label',
      'uri callback' => 'entity_class_uri',
      'module' => 'collection',
      'admin ui' => array(
        'path' => 'admin/structure/collection',
        'controller class' => 'Drupal\\collection\\CollectionUIController',
      ),
      'access callback' => 'collection_access',
    ),
  );

  if (module_exists('entitycache')) {
    $return['collection']['field cache'] = FALSE;
    $return['collection']['entity cache'] = TRUE;
  }

  return $return;
}


/**
 * Load multiple collection entities based on certain conditions.
 *
 * @param $cids
 *   An array of collection IDs.
 * @param $conditions
 *   An array of conditions to match against the {collection} table.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 * @return
 *   An array of test entity objects, indexed by pid.
 */
function collection_load_multiple($cids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('collection', $cids, $conditions, $reset);
}

/**
 * Load a collection
 */
function collection_load($name) {
  return entity_load('collection', array($name));
}

/**
 * Entity Form
 */
function collection_form($form, &$form_state, $collection, $op) {

  $form['collection'] = array(
    '#type' => 'value',
    '#value' => $collection,
  );

  $form['label'] = array(
    '#type' => 'textfield',
    '#title' => t('Label'),
    '#default_value' => $collection->label(),
  );

  $form['name'] = array(
    '#type' => 'machine_name',
    '#default_value' => $collection->identifier(),
    '#maxlength' => 32,
    '#machine_name' => array(
      'exists' => 'collection_load',
      'source' => array('label'),
    ),
    '#description' => t('A unique machine-readable name for this collection. It must only contain lowercase letters, numbers, and underscores.'),
  );

  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save Collection'),
    '#weight' => 40,
  );

  $form['actions']['delete'] = array(
    '#type' => 'submit',
    '#value' => t('Delete Collection'),
    '#weight' => 45,
    '#limit_validation_errors' => array(),
    '#submit' => array('collection_form_submit_delete')
  );

  return $form;
}

/**
 * Form API submit callback for the type form.
 */
function collection_form_submit(&$form, &$form_state) {
  $collection = entity_ui_form_submit_build_entity($form, $form_state);

  $collection->status = ENTITY_IN_DB;
  $collection->save();
  $form_state['redirect'] = 'admin/structure/collection';
}

/**
 * Form API submit callback for the delete button.
 */
function collection_form_submit_delete(&$form, &$form_state) {
  $form_state['redirect'] = 'admin/structure/collection/manage/' . $form_state['collection']->type . '/delete';
}

/**
 * Determines whether the given user has access to a collection.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create', 'delete'
 *   or just 'edit' (being the same as 'create' or 'update').
 * @param $collection
 *   Optionally a collection If nothing is
 *   given, access for all collections is determined.
 * @param $account
 *   The user to check for. Leave it to NULL to check for the current user.
 * @return boolean
 *   Whether access is allowed or not.
 */
function collection_access($op, $collection = NULL, $account = NULL) {
  // Only real permissions are view, delete, create and edit
  switch ($op) {
    case 'view':
    case 'delete':
    case 'create':
      break;
    case 'add':
      $op = 'create';
      break;
    default:
      $op = 'edit';
  }

  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  if (user_access('administer collections', $account)) {
    return TRUE;
  }

  $perm = "$op collection";
  if (user_access($perm, $account)) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_permissions().
 */
function collection_permission() {
  $perms = array(
    'administer collections' =>  array(
      'title' => t('Administer collections'),
      'description' => t('Edit and view all collections.'),
    ),
    'create collection' => array(
      'title' => t('Add a collection'),
    ),
    'edit collection' => array(
      'title' => t('Add a collection'),
    ),
    'view collection' => array(
      'title' => t('View a collection'),
    ),
    'delete collection' => array(
      'title' => t('Delete a collection'),
    ),
  );

  return $perms;
}

function collection_view($collection) {
  /*$form['usage'] = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array('collection-usage-tab'),
    ),
    '#process' => 'collection_form_process_usage',
    '#theme' => 'collection_form_usage',
  );*/
}

function collection_autocomplete($text = '', $current = '') {
  $query = db_select('collection', 'c')
    ->fields('c', array('label'))
    ->condition('label', '%' . db_like($text) . '%', 'LIKE')
    ->range(0, 10);

  if ($current) {
    $query->condition('label', $current, 'NOT');
  }

  $data = $query->execute()->fetchCol();

  drupal_json_output(array_combine($data, $data));
}
